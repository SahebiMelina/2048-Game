# 2048-Game
کتابخانه‌های مورد نیاز برای بازی را وارد می‌کنیم، مانند نام پای برای عملیات ریاضی، پای گیم که برای توسعه بازی در پایتون ضروری است، رندوم برای تولید اعداد تصادفی و همچنین سیستم سپسیفیک برای پارامترها و توابع خاص 

ثابت‌هایی که تعریف کردیم، که در فایل دیتا هم موجود هستند.

سپس یک تابع برای محاسبه امتیاز بازیکن می‌سازیم: در ابتدا امتیاز و بهترین امتیاز صفر هستند تا زمانی که بازیکن شروع به بازی کند، که این مقادیر به‌روزرسانی خواهند شد. با این حال، اگر بخواهیم بازی جدیدی شروع کنیم، هر دو مقدار به صفر باز خواهند گشت.

سپس صفحه اصلی بازی را رسم می‌کنیم تا بر اساس ثابت‌هایی که انتخاب کرده‌ایم نمایش داده شود و همچنین یک پس‌زمینه سفید شفاف برای آن انتخاب می‌کنیم.

سپس فونت و استایل‌هایی که می‌خواهیم استفاده کنیم را برای نمایش وضعیت "بازی تمام شده" انتخاب می‌کنیم تا در صورت وقوع این وضعیت، به بازیکن نشان دهیم. موقعیت دقیق نمایش بازی تمام شده نیز در این فایل در مرکز صفحه قرار دارد.

سپس یک تصویر برای دکمه "سعی دوباره" قرار می‌دهیم و آن را بر روی صفحه نمایش می‌دهیم. اندازه‌ها نیز به طور دقیق اندازه‌گیری شده‌اند و از پای گیم برای قرار دادن آن در موقعیت دلخواه استفاده کرده‌ایم.

متغیر سلف.اکتیو وضعیت بازی را پیگیری می‌کند که آیا بازی در حال اجرا است یا متوقف شده است.

حالا اگر بازیکن بازی تمام شده باشد، تابعی داریم که این وضعیت را به او نشان می‌دهد، اما تا زمانی که بازیکن می‌تواند به بازی ادامه دهد، این پنجره در پس‌زمینه مخفی می‌ماند. استفاده از بلیت باعث می‌شود چیزی مخفی بماند تا زمانی که نیاز به نمایش آن داشته باشیم.

سپس تمام چیزهایی که می‌خواهیم در صفحه نمایش قرار بگیرند، مانند آیکون منو، آیکون بازی جدید و غیره، با رنگ و موقعیت خاص خود قرار می‌دهیم.

سپس تابعی داریم که مسئول ذخیره امتیازهای بازیکن است و همچنین مستطیلی که امتیاز بازیکن را نمایش می‌دهد، موقعیت‌گذاری می‌کند.

سپس تابعی داریم که مسئول بررسی این است که آیا بازیکن روی دکمه "سعی دوباره" کلیک کرده است یا نه. اگر این کار را کرده باشد، صفحه بازی را دوباره راه‌اندازی می‌کنیم. اما اگر بازیکن روی دکمه "بازی جدید" کلیک کرده باشد، صفحه بازی را بازنشانی می‌کنیم و اگر هیچ یک از این شرایط اتفاق نیفتد، هیچ اتفاقی نمی‌افتد.

یک کلاس برای صفحه نمایش خود می‌سازیم و همچنین یک ماتریس از مستطیل‌های عددی و رابط کاربری گرافیکی  می‌سازیم و از فونت سیستم خاص و برخی اشیاء بولی برای کنترل جریان بازی استفاده می‌کنیم.

سپس تابع درا-بورد را می‌سازیم که ابتدا فاصله بین کاشی‌ها در ردیف‌ها و ستون‌ها را مشخص می‌کند و سپس آن‌ها را رسم می‌کند.

سپس اطمینان حاصل می‌کنیم که کاشی‌ها به صورت یکنواخت با فاصله‌ای که از قبل انتخاب کرده‌ایم گپ در ردیف‌ها و ستون‌ها قرار دارند.

تابعی برای تولید کاشی‌ها می‌سازیم که ابتدا بررسی می‌کند آیا کاشی خالی است تا مختصات آن را به لیست اضافه کند. سپس یک عدد تصادفی بین 1 و 10 انتخاب می‌کند که به طور پیش‌فرض 2 است و اگر عدد بیشتر از 7 بود، 4 قرار می‌دهد.

سپس حرکت کاشی‌ها را در جهت‌های مختلف تعریف می‌کنیم و ردیف‌ها و ستون‌ها را جابه‌جا می‌کنیم. سپس از بلوک ترای استفاده می‌کنیم تا بررسی کنیم آیا بازیکن در محدوده بازی حرکت می‌کند یا نه. این کار به صورت بازگشتی انجام می‌شود و در دو موقعیت بررسی می‌شود که آیا کاشی و کاشی بعدی خالی هستند یا هر دو پر هستند.

سپس مشخص می‌کنیم که چگونه و در چه زمانی از این تابع برای حرکت کاشی‌ها در ردیف‌ها و ستون‌ها استفاده کنیم. اما کاشی باید خالی باشد تا این تابع فراخوانی شود.

سپس تابعی برای بررسی این که آیا صفحه بازی از کاشی‌های عددی پر است یا نه، می‌سازیم.

سپس تابعی می‌سازیم که تمام ردیف‌ها و ستون‌ها را بررسی می‌کند تا مطمئن شویم تمام مقادیر متفاوت هستند تا دیگر نتوانیم حرکتی انجام دهیم. در غیر این صورت، مقدار فالس برمی‌گرداند.

سپس دو تابع می‌سازیم که وقتی بازیکن بازی تمام شده باشد و نیاز به شروع دوباره داشته باشد، استفاده می‌شوند.

سپس پنجره بازی را راه‌اندازی می‌کنیم و بازی را با 2 کاشی عددی شروع می‌کنیم و از توابع و حلقه‌هایی که در بازی ساخته‌ایم، استفاده می‌کنیم.

و در نهایت، اگر بازیکن روی سمت چپ موس کلیک کرده باشد، منو فعال می‌شود و بازی به‌روزرسانی می‌شود.

